/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type hpm_stat_t = u32;
#[doc = "< Address range: [0, 7]"]
pub const otp_region0_mask: otp_region_t = 1;
#[doc = "< Address range: [8, 15]"]
pub const otp_region1_mask: otp_region_t = 2;
#[doc = "< Address range: [16, 127]"]
pub const otp_region2_mask: otp_region_t = 4;
#[doc = "< Address range: user defined"]
pub const otp_region3_mask: otp_region_t = 8;
#[doc = " Definitions\n/\n/**\n @brief OTP region definitions"]
pub type otp_region_t = ::core::ffi::c_uint;
pub const otp_no_lock: otp_lock_option_t = 0;
pub const otp_read_only: otp_lock_option_t = 1;
pub const otp_permanent_no_lock: otp_lock_option_t = 2;
pub const otp_disable_access: otp_lock_option_t = 3;
pub const otp_lock_option_max: otp_lock_option_t = 3;
#[doc = " @brief OTP lock options"]
pub type otp_lock_option_t = ::core::ffi::c_uint;
#[doc = "  @brief XPI_Type definitions for\n  @note For compatibility"]
pub type XPI_Type = u32;
#[doc = "< The address is based on the device connected to Channel A1"]
pub const xpi_xfer_channel_a1: xpi_xfer_channel_t = 0;
#[doc = "< The address is based on the device connected to Channel A2"]
pub const xpi_xfer_channel_a2: xpi_xfer_channel_t = 1;
#[doc = "< The address is based on the device connected to Channel B1"]
pub const xpi_xfer_channel_b1: xpi_xfer_channel_t = 2;
#[doc = "< The address is based on the device connected to Channel B2"]
pub const xpi_xfer_channel_b2: xpi_xfer_channel_t = 3;
#[doc = "< The channel is auto determined"]
pub const xpi_xfer_channel_auto: xpi_xfer_channel_t = 4;
#[doc = " @brief XPI Transfer Channel type definitions"]
pub type xpi_xfer_channel_t = ::core::ffi::c_uint;
#[doc = "< Port:  Channel A1"]
pub const xpi_channel_a1: xpi_channel_t = 0;
#[doc = "< Port:  Channel A2"]
pub const xpi_channel_a2: xpi_channel_t = 1;
#[doc = "< Port:  Channel B1"]
pub const xpi_channel_b1: xpi_channel_t = 2;
#[doc = "< Port:  Channel B2"]
pub const xpi_channel_b2: xpi_channel_t = 3;
#[doc = " @brief XPI Channel defitions"]
pub type xpi_channel_t = ::core::ffi::c_uint;
#[doc = " @brief XPI Xfer context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_xfer_ctx_t {
    #[doc = "< device address for XPI transfer"]
    pub addr: u32,
    #[doc = "< channel for XPI transfer"]
    pub channel: u8,
    #[doc = "< command type for XPI transfer"]
    pub cmd_type: u8,
    #[doc = "< Sequence index for XPI transfer"]
    pub seq_idx: u8,
    #[doc = "< Sequence number for XPI transfer"]
    pub seq_num: u8,
    #[doc = "< Buffer for XPI transfer"]
    pub buf: *mut u32,
    #[doc = "< Transfer size in bytes"]
    pub xfer_size: u32,
}
#[doc = " @brief XPI instruction sequence"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_instr_seq_t {
    pub entry: [u32; 4usize],
}
#[doc = " @brief XPI configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_config_t {
    #[doc = "< Read sample clock source"]
    pub rxclk_src: u8,
    #[doc = "< Reserved"]
    pub reserved0: [u8; 7usize],
    #[doc = "< Tx watermark in double words"]
    pub tx_watermark_in_dwords: u8,
    #[doc = "< Rx watermark in double words"]
    pub rx_watermark_in_dwords: u8,
    #[doc = "< Enable differential clock"]
    pub enable_differential_clk: u8,
    #[doc = "< Reserved"]
    pub reserved1: [u8; 5usize],
    #[doc = "< Access flags"]
    pub access_flags: u32,
}
#[doc = " @brief XPI Device Configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_device_config_t {
    #[doc = "< Device size in kbytes"]
    pub size_in_kbytes: u32,
    #[doc = "< XPI serial root clock frequency"]
    pub serial_root_clk_freq: u32,
    #[doc = "< Enable write mask, typically for PSRAM/HyperRAM"]
    pub enable_write_mask: u8,
    #[doc = "< Data valid time, Unit 0.1ns"]
    pub data_valid_time: u8,
    pub reserved0: [u8; 2usize],
    #[doc = "< CS hold time, cycles in terms of FLASH clock"]
    pub cs_hold_time: u8,
    #[doc = "< CS setup time, cycles in terms of FLASH clock"]
    pub cs_setup_time: u8,
    #[doc = "< CS interval, cycles in terms of FLASH clock"]
    pub cs_interval: u16,
    pub reserved1: u8,
    #[doc = "< Column address bits"]
    pub column_addr_size: u8,
    #[doc = "< Enable word address, for HyperFLASH/HyperRAM"]
    pub enable_word_address: u8,
    #[doc = "< Delay target"]
    pub dly_target: u8,
    #[doc = "< AHB write sequence index"]
    pub ahb_write_seq_idx: u8,
    #[doc = "< AHB write sequence number"]
    pub ahb_write_seq_num: u8,
    #[doc = "< AHB read sequence index"]
    pub ahb_read_seq_idx: u8,
    #[doc = "< AHB read sequence number"]
    pub ahb_read_seq_num: u8,
    #[doc = "< AHB write wait interval, in terms of FLASH clock"]
    pub ahb_write_wait_interval: u8,
    pub reserved2: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_ahb_buffer_cfg_t {
    pub entry: [xpi_ahb_buffer_cfg_t__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_ahb_buffer_cfg_t__bindgen_ty_1 {
    pub priority: u8,
    pub master_idx: u8,
    pub buf_size_in_dword: u8,
    pub enable_prefetch: bool,
}
#[doc = " @brief XPI NOR configuration option\n        The ROM SW can detect the FLASH configuration based on the following structure specified by the end-user"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xpi_nor_config_option_t {
    pub header: xpi_nor_config_option_t__bindgen_ty_1,
    pub option0: xpi_nor_config_option_t__bindgen_ty_2,
    pub option1: xpi_nor_config_option_t__bindgen_ty_3,
    pub option2: xpi_nor_config_option_t__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xpi_nor_config_option_t__bindgen_ty_1 {
    pub __bindgen_anon_1: xpi_nor_config_option_t__bindgen_ty_1__bindgen_ty_1,
    pub U: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_nor_config_option_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl xpi_nor_config_option_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn words(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_words(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_tag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        words: u32,
        reserved: u32,
        tag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let words: u32 = unsafe { ::core::mem::transmute(words) };
            words as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let tag: u32 = unsafe { ::core::mem::transmute(tag) };
            tag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xpi_nor_config_option_t__bindgen_ty_2 {
    pub __bindgen_anon_1: xpi_nor_config_option_t__bindgen_ty_2__bindgen_ty_1,
    pub U: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct xpi_nor_config_option_t__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl xpi_nor_config_option_t__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn freq_opt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_freq_opt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn misc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_misc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dummy_cycles(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dummy_cycles(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn quad_enable_seq(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_quad_enable_seq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_pads_after_init(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_pads_after_init(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_pads_after_por(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_pads_after_por(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn probe_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_probe_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        freq_opt: u32,
        misc: u32,
        dummy_cycles: u32,
        quad_enable_seq: u32,
        cmd_pads_after_init: u32,
        cmd_pads_after_por: u32,
        probe_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let freq_opt: u32 = unsafe { ::core::mem::transmute(freq_opt) };
            freq_opt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let misc: u32 = unsafe { ::core::mem::transmute(misc) };
            misc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let dummy_cycles: u32 = unsafe { ::core::mem::transmute(dummy_cycles) };
            dummy_cycles as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let quad_enable_seq: u32 = unsafe { ::core::mem::transmute(quad_enable_seq) };
            quad_enable_seq as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let cmd_pads_after_init: u32 = unsafe { ::core::mem::transmute(cmd_pads_after_init) };
            cmd_pads_after_init as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let cmd_pads_after_por: u32 = unsafe { ::core::mem::transmute(cmd_pads_after_por) };
            cmd_pads_after_por as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let probe_type: u32 = unsafe { ::core::mem::transmute(probe_type) };
            probe_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xpi_nor_config_option_t__bindgen_ty_3 {
    pub __bindgen_anon_1: xpi_nor_config_option_t__bindgen_ty_3__bindgen_ty_1,
    pub U: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct xpi_nor_config_option_t__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl xpi_nor_config_option_t__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn drive_strength(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_drive_strength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_connection_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pin_group_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_pin_group_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn io_voltage(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_io_voltage(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drive_strength: u32,
        connection_sel: u32,
        pin_group_sel: u32,
        io_voltage: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let drive_strength: u32 = unsafe { ::core::mem::transmute(drive_strength) };
            drive_strength as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let connection_sel: u32 = unsafe { ::core::mem::transmute(connection_sel) };
            connection_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let pin_group_sel: u32 = unsafe { ::core::mem::transmute(pin_group_sel) };
            pin_group_sel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let io_voltage: u32 = unsafe { ::core::mem::transmute(io_voltage) };
            io_voltage as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xpi_nor_config_option_t__bindgen_ty_4 {
    pub __bindgen_anon_1: xpi_nor_config_option_t__bindgen_ty_4__bindgen_ty_1,
    pub U: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_nor_config_option_t__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
impl xpi_nor_config_option_t__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn flash_size_option(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flash_size_option(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_sector_size_option(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flash_sector_size_option(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_sector_erase_cmd_option(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flash_sector_erase_cmd_option(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flash_size_option: u32,
        flash_sector_size_option: u32,
        flash_sector_erase_cmd_option: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let flash_size_option: u32 = unsafe { ::core::mem::transmute(flash_size_option) };
            flash_size_option as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let flash_sector_size_option: u32 =
                unsafe { ::core::mem::transmute(flash_sector_size_option) };
            flash_sector_size_option as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let flash_sector_erase_cmd_option: u32 =
                unsafe { ::core::mem::transmute(flash_sector_erase_cmd_option) };
            flash_sector_erase_cmd_option as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Device Mode confiuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_mode_cfg_t {
    #[doc = "< Configuration command type"]
    pub cfg_cmd_type: u8,
    #[doc = "< Size for parameter"]
    pub param_size: u8,
}
#[doc = " @brief XPI NOR device information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_device_info_t {
    #[doc = "< Device Size in Kilobytes, offset 0x00"]
    pub size_in_kbytes: u32,
    #[doc = "< Page size, offset 0x04"]
    pub page_size: u16,
    #[doc = "< Sector size in kilobytes, offset 0x06"]
    pub sector_size_kbytes: u16,
    #[doc = "< Block size in kilobytes, offset 0x08"]
    pub block_size_kbytes: u16,
    #[doc = "< Busy offset, offset 0x0a"]
    pub busy_offset: u8,
    #[doc = "< Busy polarity, offset 0x0b"]
    pub busy_polarity: u8,
    #[doc = "< Device Size in Kilobytes, offset 0x0c"]
    pub data_pads: u8,
    #[doc = "< Enable DDR mode, offset 0x0d"]
    pub en_ddr_mode: u8,
    #[doc = "< Clk frequency for device configuration offset 0x0e"]
    pub clk_freq_for_device_cfg: u8,
    #[doc = "< Working mode after POR reset offset 0x0f"]
    pub working_mode_por: u8,
    #[doc = "< The device working mode, offset 0x10"]
    pub working_mode: u8,
    #[doc = "< Enable Differential clock, offset 0x11"]
    pub en_diff_clk: u8,
    #[doc = "< Data valid time, in 0.1ns, offset 0x12"]
    pub data_valid_time: u8,
    #[doc = "< Enable half clock for non-read command, offset 0x13"]
    pub en_half_clk_for_non_read_cmd: u8,
    #[doc = "< Enable safe clock for non-read command, offset 0x14"]
    pub clk_freq_for_non_read_cmd: u8,
    #[doc = "< XPI DLL Delay Target, offset 0x15"]
    pub dll_dly_target: u8,
    #[doc = "< IO voltage, offset 0x16"]
    pub io_voltage: u8,
    #[doc = "< Reserved for future use, offset 0x17"]
    pub reserved0: u8,
    #[doc = "< CS hold time, 0 - default value, others - user specified value, offset 0x18"]
    pub cs_hold_time: u8,
    #[doc = "< CS setup time, 0 - default value, others - user specified value, offset 0x19"]
    pub cs_setup_time: u8,
    #[doc = "< CS interval, intervals between to CS active, offset 0x1a"]
    pub cs_interval: u8,
    #[doc = "< Enable device mode configuration, offset 0x1b"]
    pub en_dev_mode_cfg: u8,
    #[doc = "< Flash state context, offset 0x1c"]
    pub flash_state_ctx: u32,
    #[doc = "< Mode configuration sequences, offset 0x20"]
    pub mode_cfg_list: [device_mode_cfg_t; 2usize],
    #[doc = "< Mode configuration parameters, offset 0x24"]
    pub mode_cfg_param: [u32; 2usize],
    #[doc = "< Reserved for future use, offset 0x2C"]
    pub reserved1: u32,
    #[doc = "< Mode Configuration Instruction sequence, offset 0x30"]
    pub cfg_instr_seq: [xpi_device_info_t__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_device_info_t__bindgen_ty_1 {
    pub entry: [u32; 4usize],
}
#[doc = " @brief XPI NOR configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_nor_config_t {
    #[doc = "< Must be \"XNOR\", offset 0x000"]
    pub tag: u32,
    #[doc = "< Reserved for future use, offset 0x004"]
    pub reserved0: u32,
    #[doc = "< RXCLKSRC value, offset 0x008"]
    pub rxclk_src: u8,
    #[doc = "< Clock frequency, offset 0x009"]
    pub clk_freq: u8,
    #[doc = "< Drive strength, offset 0x0a"]
    pub drive_strength: u8,
    #[doc = "< Column address size, offset 0x0b"]
    pub column_addr_size: u8,
    #[doc = "< RXCLKSRC during FLASH initialization, offset 0x0c"]
    pub rxclk_src_for_init: u8,
    #[doc = "< Indicate whether device configuration is in progress, offset: 0x0d"]
    pub config_in_progress: u8,
    #[doc = "< Reserved for future use, offset 0x00f"]
    pub reserved: [u8; 2usize],
    #[doc = "< Device connection information"]
    pub chn_info: [xpi_nor_config_t__bindgen_ty_1; 4usize],
    #[doc = "< Device info, offset 0x20"]
    pub device_info: xpi_device_info_t,
    #[doc = "< Standard instruction sequence table, offset 0x70"]
    pub instr_set: [xpi_instr_seq_t; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_nor_config_t__bindgen_ty_1 {
    #[doc = "<  Port enable flag, 0 - not enabled, 1 - enabled"]
    pub enable: u8,
    #[doc = "< 0 - 1st IO group, 1 - 2nd IO group"]
    pub group: u8,
    pub reserved: [u8; 2usize],
}
#[doc = " @brief OTP driver interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otp_driver_interface_t {
    pub version: u32,
    pub init: ::core::option::Option<unsafe extern "C" fn()>,
    pub deinit: ::core::option::Option<unsafe extern "C" fn()>,
    pub read_from_shadow: ::core::option::Option<unsafe extern "C" fn(addr: u32) -> u32>,
    pub read_from_ip: ::core::option::Option<unsafe extern "C" fn(addr: u32) -> u32>,
    pub program: ::core::option::Option<
        unsafe extern "C" fn(addr: u32, src: *const u32, num_of_words: u32) -> hpm_stat_t,
    >,
    pub reload: ::core::option::Option<unsafe extern "C" fn(region: otp_region_t) -> hpm_stat_t>,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(addr: u32, lock_option: otp_lock_option_t) -> hpm_stat_t,
    >,
    pub lock_shadow: ::core::option::Option<
        unsafe extern "C" fn(addr: u32, lock_option: otp_lock_option_t) -> hpm_stat_t,
    >,
    pub set_configurable_region:
        ::core::option::Option<unsafe extern "C" fn(start: u32, num_of_words: u32) -> hpm_stat_t>,
    pub write_shadow_register:
        ::core::option::Option<unsafe extern "C" fn(addr: u32, data: u32) -> hpm_stat_t>,
}
#[doc = " @brief XPI driver interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_driver_interface_t {
    pub version: u32,
    pub get_default_config:
        ::core::option::Option<unsafe extern "C" fn(xpi_config: *mut xpi_config_t) -> hpm_stat_t>,
    pub get_default_device_config: ::core::option::Option<
        unsafe extern "C" fn(dev_config: *mut xpi_device_config_t) -> hpm_stat_t,
    >,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(base: *mut XPI_Type, xpi_config: *mut xpi_config_t) -> hpm_stat_t,
    >,
    pub config_ahb_buffer: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            ahb_buf_cfg: *mut xpi_ahb_buffer_cfg_t,
        ) -> hpm_stat_t,
    >,
    pub config_device: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            dev_cfg: *mut xpi_device_config_t,
            channel: xpi_channel_t,
        ) -> hpm_stat_t,
    >,
    pub update_instr_table: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            inst_base: *const u32,
            seq_idx: u32,
            num: u32,
        ) -> hpm_stat_t,
    >,
    pub transfer_blocking: ::core::option::Option<
        unsafe extern "C" fn(base: *mut XPI_Type, xfer: *mut xpi_xfer_ctx_t) -> hpm_stat_t,
    >,
    pub software_reset: ::core::option::Option<unsafe extern "C" fn(base: *mut XPI_Type)>,
    pub is_idle: ::core::option::Option<unsafe extern "C" fn(base: *mut XPI_Type) -> bool>,
    pub update_dllcr: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            serial_root_clk_freq: u32,
            data_valid_time: u32,
            channel: xpi_channel_t,
            dly_target: u32,
        ),
    >,
    pub get_abs_apb_xfer_addr: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            in_addr: u32,
            out_addr: *mut u32,
        ) -> hpm_stat_t,
    >,
}
#[doc = " @brief XPI NOR driver interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xpi_nor_driver_interface_t {
    pub version: u32,
    pub get_config: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            nor_cfg: *mut xpi_nor_config_t,
            cfg_option: *mut xpi_nor_config_option_t,
        ) -> hpm_stat_t,
    >,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(base: *mut XPI_Type, nor_config: *mut xpi_nor_config_t) -> hpm_stat_t,
    >,
    pub enable_write: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            addr: u32,
        ) -> hpm_stat_t,
    >,
    pub get_status: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            addr: u32,
            out_status: *mut u16,
        ) -> hpm_stat_t,
    >,
    pub wait_busy: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            addr: u32,
        ) -> hpm_stat_t,
    >,
    pub erase: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            start: u32,
            length: u32,
        ) -> hpm_stat_t,
    >,
    pub erase_chip: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
        ) -> hpm_stat_t,
    >,
    pub erase_sector: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            addr: u32,
        ) -> hpm_stat_t,
    >,
    pub erase_block: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            addr: u32,
        ) -> hpm_stat_t,
    >,
    pub program: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            src: *const u32,
            dst_addr: u32,
            length: u32,
        ) -> hpm_stat_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            dst: *mut u32,
            start: u32,
            length: u32,
        ) -> hpm_stat_t,
    >,
    pub page_program_nonblocking: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            src: *const u32,
            dst_addr: u32,
            length: u32,
        ) -> hpm_stat_t,
    >,
    pub erase_sector_nonblocking: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            addr: u32,
        ) -> hpm_stat_t,
    >,
    pub erase_block_nonblocking: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
            addr: u32,
        ) -> hpm_stat_t,
    >,
    pub erase_chip_nonblocking: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            channel: xpi_xfer_channel_t,
            nor_config: *const xpi_nor_config_t,
        ) -> hpm_stat_t,
    >,
    pub reserved0: [u32; 3usize],
    pub auto_config: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            nor_cfg: *mut xpi_nor_config_t,
            cfg_option: *mut xpi_nor_config_option_t,
        ) -> hpm_stat_t,
    >,
    pub get_property: ::core::option::Option<
        unsafe extern "C" fn(
            base: *mut XPI_Type,
            nor_cfg: *mut xpi_nor_config_t,
            property_id: u32,
            value: *mut u32,
        ) -> hpm_stat_t,
    >,
}
#[doc = " @brief Bootloader API table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bootloader_api_table_t {
    pub version: u32,
    pub copyright: *const ::core::ffi::c_char,
    pub run_bootloader:
        ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> hpm_stat_t>,
    pub otp_driver_if: *const otp_driver_interface_t,
    pub xpi_driver_if: *const xpi_driver_interface_t,
    pub xpi_nor_driver_if: *const xpi_nor_driver_interface_t,
}
